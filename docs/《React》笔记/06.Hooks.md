---
title: Hooks
date: 2021-07-13 11:39:29
permalink: /pages/026608/
categories:
  - 《React》笔记
tags:
  - 
---

# Hooks

Hooks 的出现，让 React 出现了历史变革；
<!-- more -->

## 对比以前的代码

```js
import React ,{ Component } from 'react';
class HookTest extends Component {
  constructor(props) {
    super(props);
    this.state = { count:0 }
    this.addCount = this.addCount.bind(this)
  }
  render() {
    return ( <div>{this.state.count}<button onClick={this.addCount}>点我加1</button></div> );
  }
  addCount(){
    this.setState({ count: ++this.state.count });
  }
}

export default HookTest;
```

**Hooks 写法**
```js
import React, { useState } from 'react';
function HookTest(){
    const [ count , setCount ] = useState(0);
    return ( <div>{count}<button onClick={()=>{setCount(count+1)}}>点我加1</button></div> );
}
export default HookTest;
```

真是绝绝子啊~

## useState

useState 是 react 自带的一个 hook 函数，它的作用是用来声明状态变量。

**变量声明**
```js
// useState 这个函数接收的参数是状态的初始值(Initial state)，
// 它返回一个数组，这个数组的第0位是当前的状态值，
// 第1位是可以改变状态值的方法函数。 所以上面的代码的意思就是声明了一个状态变量为count，并把它的初始值设为0，
// 同时提供了一个可以改变count的状态值的方法函数。
  const [ count , setCount ] = useState(0);
```

**使用**
```jsx
// 直接调用 setCount 函数，这个函数接收的参数是修改过的新状态值。接下来的事情就交给 React ,他会重新渲染组件。
<div>{count}<button onClick={()=>{setCount(count+1)}}>点我加1</button></div>
```

> 注意，不能在 if 语句中定义 state；另外在使用 useState 的时候只赋了初始值，并没有绑定任何的 key,那 React 是怎么保证 useState 找到它自己对应的 stat e呢？因为 React 是根据 useState 出现的顺序来确定的。

## useEffect

```js
// React 首次渲染和之后的每次渲染都会调用一遍 useEffect 函数，而之前我们要用两个生命周期函数分别表示首次渲染( componentDidMount )和更新导致的重新渲染( componentDidUpdate )。
//useEffect 中定义的函数的执行不会阻碍浏览器更新视图，也就是说这些函数时异步执行的，而 componentDidMount 和 componentDidUpdate 中的代码都是同步执行的。
useEffect(() => {
  console.log(123);
});

// componentWillUnmount 生命周期函数（组件将要被卸载时执行）。比如我们的定时器要清空，避免发生内存泄漏;比如登录状态要取消掉，避免下次进入信息出错。componentWillUnmount -解绑副作用
// useEffect 的第二个参数
// useEffect 的第二个参数，它是一个数组，数组中可以写入很多状态对应的变量，意思是当状态值发生变化时，我们才进行解绑。但是当传空数组[]时，就是当组件将被销毁时才进行解绑，这也就实现了 componentWillUnmount 的生命周期函数。
// 但是如果我们想每次 count 发生变化，我们都进行解绑，只需要在第二个参数的数组里加入 count 变量就可以了。
useEffect(() => {
  console.log('++++');
}, [count]);
```

## useContext

useContext 跨越组件层级直接传递变量，实现共享。需要注意的是 useContext 和 redux 的作用是不同的，一个解决的是组件之间值传递的问题，一个是应用中统一管理状态的问题，但通过和 useReducer 的配合使用，可以实现类似 Redux 的作用。

```jsx
  // 子组件
  function Counter(){
      const count = useContext(CountContext)  //一句话就可以得到count
      return (<h2>{count}</h2>)
  }
  // 父组件
 // 1、创建一个 createContext
 // const CountContext = createContext()
  {/* 2、 创建一个上下文变量 */}
  <CountContext.Provider value={count}>
    <Counter />
  </CountContext.Provider>
  <button onClick={()=>{setCount(count+1)}}>click me</button>
```

> Context 的作用就是对它所包含的组件树提供全局共享数据的一种技术。

## useReducer

useReducer 通过 action 的传递，更新复杂逻辑的状态，主要是可以实现类似 Redux 中的 Reducer 部分，实现业务逻辑的可行性。

```jsx
import React, { useReducer } from 'react';

function ReducerDemo(){
    const [ count , dispatch ] =useReducer((state,action)=>{
        switch(action){
            case 'add':
                return state+1
            case 'sub':
                return state-1
            default:
                return state
        }
    },0)
    return (
       <div>
           <h2>现在的分数是{count}</h2>
           <button onClick={()=>dispatch('add')}>Increment</button>
           <button onClick={()=>dispatch('sub')}>Decrement</button>
       </div>
    )

}

export default ReducerDemo
```