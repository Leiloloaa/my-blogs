---
title: JS单线程理解
date: 2021-03-10 11:34:37
permalink: /pages/aa182f/
categories:
  - 面试
  - JavaScript
tags:
  - 
---

> 众所周知，js是一个单线程的语言，这意味着同一时间只能做一件事，但是我们又说js是异步的。首先，单线程并不是没有优点。作为浏览器脚本语言，JavaScript 的主要用途是与用户互动，以及操作 DOM。这决定了它只能是单线程，否则会带来很复杂的同步问题。比如，假定 JavaScript 同时有两个线程，一个线程在某个 DOM 节点上添加内容，另一个线程删除了这个节点，那最后应该以哪个为准呢？ 所以，为了避免复杂性，从一诞生，JavaScript 就是单线程，这已经成了这门语言的核心特征，将来也不会改变。

实际上，主线程只会做一件事情，就是从消息队列里面取消息、执行消息，再取消息、再执行。当消息队列为空时，就会等待直到消息队列变成非空。而且主线程只有在将当前的消息执行完成后，才会去取下一个消息。这种机制就叫做事件循环机制，取一个消息并执行的过程叫做一次循环 。就如图所示一样

![image.png](https://images.dbabox.ltd/images/2021/03/10/image.png)

> 如果说js只有一个主线程，那么它应该有三个辅助的子线程，分别为事件处理线程、http网络请求线程、定时器处理线程。这些线程就是实现js异步的关键，比如主线程内有程序正在运行，这个时候后面有一个定时器在等待，那么主线程肯定不会检测这个定时器的时间是否达到要求的，这样会消耗性能和时间，所以就交给定时器处理线程，当setTimeout的时间达到时，它就会把这个定时器里的函数（其实这就是回调函数了）放到任务队列里，当主线程把执行栈中的任务都执行完以后，执行栈为空了，就会从任务队列里找，执行里面的回调，如此循环往复，这就是时间循环。由于执行任务还是只有一个主线程可以做，所以有时候即使定时器触发的事件已经到了，但是它的回调函数也只能在任务队列中等待，这导致最后函数触发的事件往往比设置的时间长，这也是我们说定时器准确度不高的原因。

## JS为什么需要异步?

>场景描述:
如果JS中不存在异步,只能自上而下执行,如果上一行解析时间很长,那么下面的代码就会被阻塞。
对于用户而言,阻塞就意味着"卡死",这样就导致了很差的用户体验

## JS单线程又是如何实现异步的呢?

> 既然JS是单线程的,只能在一条线程上执行,又是如何实现的异步呢?是通过的事件循环(event loop),理解了event loop机制,就理解了JS的执行机制

**按照同步任务和异步任务：JS的执行机制是**

- 首先判断JS是同步还是异步,同步就进入主线程,异步就进入event table
- 异步任务在event table中注册函数,当满足触发条件后,被推入event queue
- 同步任务进入主线程后一直执行,直到主线程空闲时,才会去event queue中查看是否有可执行的异步任务,如果有就推入主线程中

**精准概况**

- macro-task(宏任务)：包括整体代码script，setTimeout，setInterval
- micro-task(微任务)：Promise，process.nextTick

**按照这种分类方式：JS的执行机制是**

**执行一个宏任务,过程中如果遇到微任务,就将其放到微任务的【事件队列】里；当前宏任务执行完成后,会查看微任务的【事件队列】,并将里面全部的微任务依次执行完**

```javascript
setTimeout(function(){
    console.log('定时器开始啦')
});

new Promise(function(resolve){
    console.log('马上执行for循环啦');
    for(var i = 0; i < 10000; i++){
        i == 99 && resolve();
    }
}).then(function(){
    console.log('执行then函数啦')
});

console.log('代码执行结束');
```

> 首先执行script下的宏任务,遇到setTimeout,将其放到宏任务的【队列】里
遇到 new Promise直接执行,打印"马上执行for循环啦"
遇到then方法,是微任务,将其放到微任务的【队列里】
打印 "代码执行结束"
本轮宏任务执行完毕,查看本轮的微任务,发现有一个then方法里的函数, 打印"执行then函数啦"
到此,本轮的event loop 全部完成。
下一轮的循环里,先执行一个宏任务,发现宏任务的【队列】里有一个 setTimeout里的函数,执行打印"定时器开始啦"
